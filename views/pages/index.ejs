<!DOCTYPE html>
<html>
<head>
  <% include ../partials/header.ejs %>
    <link rel="stylesheet" type="text/css" href="/stylesheets/index.css" />
</head>
<body>

<div class="background">
</div>
<div id="people">
<!--    <div class="person"><img class="person-img" src="texture/1.png"></div>-->
</div>
<div id="container">
    <div class="lds-ellipsis"><div></div><div></div><div></div><div></div></div>
    <div id="inner"></div>
</div>

<script type="text/javascript">

    const CALL_ID = {
        "GET_STORY_TODAY" : 1,
        "GET_STORY_IN_RANGE" : 2,
        "GET_DEFAULT_FG" : 3,
        "GET_DEFAULT_BG" : 4,
        "GET_STORY_DATE" : 5,
        "REMOVE_WORD_TODAY": 6,
        "REMOVE_WORD": 7,
        "ADD_NORMAL_WORD" : 8,
        "ADD_FANCY_WORD" : 9,
        "REPLACE_WORD" : 10,
        "UPDATE_STORY" : "update",
        "GET_MIN_AMOUNT" : 11
    };

    const MAINNET_URL = '<%- URL %>';

    let arr = window.location.href.split("/");
    const MY_URL = arr[0] + "//" + arr[2];

    let isICONEX = false;

    const IconService = window['icon-sdk-js'];

    const provider = new IconService.HttpProvider(MAINNET_URL);
    const iconService = new IconService(provider);
    const IconConverter = IconService.IconConverter;
    const IconBuilder = IconService.IconBuilder;

    const scoreAddress = '<%- SCORE %>';
    let fromAddress = "";

    let recentlyEditedIndex = 0;

    let storyInitComplete = false;

    let EditingUsers = new Array(16).fill(0);

    const DECIMAL = 10 ** 18;

    let minAmount = 0;


    jQuery.fn.insertAt = function(index, element) {
        let lastIndex = this.children().length;
        if (index < 0) {
            index = Math.max(0, lastIndex + 1 + index);
        }
        this.append(element);
        if (index < lastIndex) {
            this.children().eq(index).before(this.children().last());
        }
        return this;
    }

    makePostCall = function (data) { // here the data and url are not hardcoded anymore
        console.log("[OWN] Sending JSON call...");
        console.log(data);

        let json_data = JSON.stringify(data);

        return $.ajax({
            type: "POST",
            url: "https://bicon.net.solidwallet.io/api/v3",
            data: json_data,
            crossDomain: true,
            dataType: "json",
            contentType: "application/json"
        }).done(function(data) {
            console.log("[OWN] Got response: ");
            onJSONsuccess(data);
        }).fail(function(sender, message, details) {
            console.log("makePostCall Error!");
            console.log(message);
            console.log(details);
        });
    };

    let pop = new Howl({
        src: ['/sounds/pop.mp3'],
        sprite: {
            ding : [0, 1000]
        },
        autoplay: false
    });

    function notifySound() {
        pop.play("ding");
    }

    function setIntervalX(callback, delay, repetitions) {
        var x = 0;
        var intervalID = window.setInterval(function () {

            callback();

            if (++x === repetitions) {
                window.clearInterval(intervalID);
            }
        }, delay);
    }

    let region = "<%- REGION %>";

    let numOfPeople = 0;


    function generateFaceDivString(dataID) {
        return '<div class="person person-connected" data-id="' + dataID + '" >' +
            '<img class="typing-icon" src="/images/typingicon.png"  alt="typing">' +
            '<img class="person-img" src="/images/smilyface_sm.png"  alt="person">' +
            '</div>'

    }

    //
    // SOCKETS
    //

    initPersonCSS = function(target) {
        let randX = Math.random() * 38 - 19;
        let scaleX = 1;
        if (randX > 0) {
            randX = randX + 70;

        }
        else {
            randX = randX + 20;
            scaleX = -1;
        }
        let randY = Math.random() * 55 + 5;
        let zIndex = Math.round(100 - randY);

        $(target).css({
            "position" : "absolute",
            "right" : randX + "vw",
            "bottom" : randY + "vh",
            "transform" : "scaleX(" + scaleX +")",
            "z-index" : zIndex
        });
    };

    socket = io("/" + region);

    // data contains list of socket.id of people who are connected.
    socket.on('init', function (data, editingUsers) {
        console.log(data);
        console.log("Total number of people on server: " + data.length);
        numOfPeople = data.length;

        EditingUsers = editingUsers;

        let string = "";
        for(let i = 0; i < numOfPeople; i++){
            string+= generateFaceDivString(data[i])
        }
        $("#people").append(string);

        $(".person").each(function() {
            initPersonCSS(this);
        });

        anime({
            targets: ".person-connected",
            opacity: 1,
            translateY: [100, 0],
            delay: anime.stagger(150, {start: 1000}),
            duration: 1000,
            changeBegin: function(anim) {
                setIntervalX(notifySound, 100, numOfPeople);
            },
        });

    });

    socket.on('enter', function (data) {
        console.log("User " + data + " entered!");
        numOfPeople++;
        console.log("Total number of people on server: " + numOfPeople);

        let newlyAdded = $(generateFaceDivString(data)).appendTo("#people");

        initPersonCSS(newlyAdded[0]);

        anime({
            targets: newlyAdded[0],
            opacity: 1,
            translateY: [100, 0],
            duration: 1000,

        });
        notifySound();
    });

    socket.on('exit', function (data, index) {
        console.log("User " + data + " left... ", index);
        numOfPeople--;
        console.log("Total number of people on server: " + numOfPeople);

        let personToRemove = $(".person-connected[data-id=\"" + data + "\"]");
        personToRemove.removeClass("person-connected");
        anime({
            targets: personToRemove[0],
            opacity: 0,
            translateY: [0, 100],
            duration: 500,
            easing: "easeOutCubic",
            complete: function(anim) {
                personToRemove.remove();
            }
        });

        if (storyInitComplete && index > -1) {
            let indexObj = $("#inner");
            let childObj = indexObj.children().eq(index);
            if (childObj) {
                childObj.removeClass("editing");
            }
        }

    });

    startWriting = function(index) {
        socket.emit("startWriting", index);
        anime({
            targets: ".person-connected[data-id=\"" + socket.id + "\"] .typing-icon",
            opacity: 1,
            translateX: ["-50%", "-50%"],
            translateY: ["20%", 0],
            duration: 300,
            easing: "easeOutQuad"
        });
    };

    socket.on("startWriting", function(id, index) {
        console.log(id + " started writing");
        anime({
            targets: ".person-connected[data-id=\"" + id + "\"] .typing-icon",
            opacity: 1,
            translateX: ["-50%", "-50%"],
            translateY: ["20%", 0],
            duration: 300,
            easing: "easeOutQuad"
        });

        if (storyInitComplete) {
            let indexObj = $("#inner");
            let childObj = indexObj.children().eq(index);
            if (childObj) {
                childObj.addClass("editing");
            }
        } else {
            EditingUsers[index] = id;
        }
    });

    cancelWriting = function(index) {
        socket.emit("cancelWriting", index);
        anime({
            targets: ".person-connected[data-id=\"" + socket.id + "\"] .typing-icon",
            opacity: 0,
            translateX: ["-50%", "-50%"],
            translateY: [0, "-40%"],
            duration: 300,
            easing: "easeOutQuad"
        });
    };

    socket.on("cancelWriting", function(id, index) {
        anime({
            targets: ".person-connected[data-id=\"" + id + "\"] .typing-icon",
            opacity: 0,
            translateX: ["-50%", "-50%"],
            translateY: [0, "-40%"],
            duration: 300,
            easing: "easeOutQuad"
        });

        if (storyInitComplete) {
            let indexObj = $("#inner");
            let childObj = indexObj.children().eq(index);
            if (childObj) {
                childObj.removeClass("editing");
            }
        } else {
            EditingUsers[index] = 0;
        }

    });

    finishWriting = function(index, isInsert) {
        socket.emit("finishWriting", index, isInsert);
        anime({
            targets: ".person-connected[data-id=\"" + socket.id + "\"] .typing-icon",
            opacity: 0,
            translateX: ["-50%", "-50%"],
            translateY: [0, "-40%"],
            duration: 300,
            easing: "easeOutCubic"
        });
        updateStory(index, isInsert);
    };


    socket.on("finishWriting", function(id, index, isInsert) {
        anime({
            targets: ".person-connected[data-id=\"" + id + "\"] .typing-icon",
            opacity: 0,
            translateX: ["-50%", "-50%"],
            translateY: [0, "-40%"],
            duration: 300,
            easing: "easeOutCubic"
        });
        updateStory(index, isInsert);
        if (storyInitComplete) {
            let indexObj = $("#inner");
            let childObj = indexObj.children().eq(index);
            if (childObj) {
                childObj.removeClass("editing");
            }
        }
    });

    updateStoryGraphics = function(data, index, isInsert) {
        console.log(data);
        let s = constructWordString(data.result.wordFG, data.result.wordBG, data.result.word, data.result.wordOwner, data.result.wordValue);
        let indexObj = $("#inner");

        if (isInsert === 0) {
            indexObj.children().eq(index).remove();
        }
        indexObj = indexObj.insertAt(index, s);

        if (index >= indexObj.children().length) {
            index = Math.max(0, indexObj.children().length - 1);
        }

        indexObj.children().eq(index).css({"z-index": index + 1,
        "position": "initial"});

        anime({
            targets: indexObj.children().eq(index)[0],
            opacity: [0,1],
            duration: 1000
        });
    }

    window.addEventListener("ICONEX_RELAY_RESPONSE", eventHandler, true);

    function eventHandler(event) {
        const type = event.detail.type
        const payload = event.detail.payload
        switch (type) {
            case "RESPONSE_HAS_ACCOUNT":
                isICONEX = payload.hasAccount;
                console.log("[ICONEX] User has ICONEX installed.");
                break;
            case "RESPONSE_ADDRESS":
                fromAddress = payload;
                console.log("[ICONEX] User selected " + fromAddress);
                break;
            case "RESPONSE_JSON-RPC":
                console.log("[ICONEX] Got JSON Response: ");
                onJSONsuccess(payload);
                break;
            default:
        }
    }

    function onWordFocus(x) {
        if(!checkForICONex())
            return;

        let xx = $(x);

        if (xx.hasClass("editing")) {

        }
        else {
            if (xx.hasClass("meEditing")) {


            }
            else {
                x.contentEditable = true;
                x.focus();

                xx.attr("data-newword", xx.attr("data-word"));
                xx.css("text-decoration", "underline");
                xx.css("position", "initial");
                xx.on('input', function(e) {
                    if (xx.text() !== "") {
                        xx.text(xx.text().replace(/\s/g, ""));
                        if (xx.text().length > 16) {
                            xx.text(xx.text().slice(0, 16));
                        }
                        let arr = calculateStyle(xx.text());
                        xx.css({
                            "background-color": COLORS[arr[0]],
                            "color": COLORS[arr[1]]
                        });
                        if (xx.text() !== xx.attr("data-word")) {
                            xx.attr("data-newword", xx.text());
                        }
                        placeCaretAtEnd(x);
                    }
                });
                xx.on('keydown', function(e) {
                    if (e.which === 13) {
                        triggerReplaceWord(xx, xx.attr("data-newword"));
                        //Prevent insertion of a return
                        //You could do other things here, for example
                        //focus on the next field



                        return false;
                    }
                });
                let i = $(".word").index(x);
                $(x).addClass("meEditing");
                startWriting(i);
                console.log("focus", x);
            }
        }
    }

    triggerReplaceWord = function(el, newWord) {
        let value = parseInt(el.attr("data-value"));
        let needValue = value * 1.1001;
        if (needValue === 0)
            needValue = minAmount;

        Swal.fire({
            type: 'question',
            title: 'Replace an existing word',
            text: 'You need at least ' + (needValue / DECIMAL) + " ICX to replace this word to '" + newWord + "'. Would you like to continue?",
            showCancelButton: true,
            confirmButtonText: 'Yes, replace it',
            cancelButtonText: 'Cancel',
        }).then((result) => {
            if (result.value) {
                replaceWord(el.index(), newWord, needValue);

            } else if (
                // Read more about handling dismissals
                result.dismiss === Swal.DismissReason.cancel
            ) {
                el.text(el.attr("data-word"));
                el.css({
                    "background-color": el.attr("data-calculatedBG"),
                    "color": el.attr("data-calculatedFG")
                });
            }
        })
    };

    function onWordBlur(x) {
        let jEl = $(x);

        if (jEl.hasClass("meEditing")) {
            let i = $(".word").index(x)
            cancelWriting(i);
            console.log("blur", x);
            jEl.removeClass("meEditing")
            x.contentEditable = false;

            jEl.text(jEl.attr("data-word"));
            jEl.css({
                "background-color": jEl.attr("data-calculatedBG"),
                "color": jEl.attr("data-calculatedFG")
            });
            jEl.css("text-decoration", "none");
        }
    }

    function constructWordString(fgColor, bgColor, word, owner, value) {
        fgColor = "#" + fgColor.toString(16).substr(2);
        bgColor = "#" + bgColor.toString(16).substr(2);

        let arr = calculateStyle(word);

        let fontSize = 7;

        value = IconService.IconAmount.of(value, IconService.IconAmount.Unit.ICX);


        if (value === 0) {
            fontSize = 5;
        } else {
            fontSize = Math.min(1 + (value / DECIMAL) / 5, 2) * 5;
        }


        return "<span spellcheck=\"false\" class='word' " +
            "style='color:" + COLORS[arr[1]] + "; background-color:" + COLORS[arr[0]] + "; opacity: 0; font-size: " + fontSize + "vmin;' " +
            "data-owner='" + owner + "' " +
            "data-value='" + value + "' " +
            "data-word='" + word + "' " +
            "data-fg='" + fgColor + "' " +
            "data-bg='" + bgColor + "' " +
            "data-calculatedFG='" + COLORS[arr[1]] + "' " +
            "data-calculatedBG='" + COLORS[arr[0]] + "' " +
            "onclick='onWordFocus(this)' " +
            "onblur='onWordBlur(this)' " +
            ">"
            + escapeHtml(word)
            + "</span>"
    }

    function initTodayStory(data) {
        let story = data.result.story;
        let storyOwner = data.result.storyOwner;
        let storyValue = data.result.storyValue;
        let styleFG = data.result.styleFG;
        let styleBG = data.result.styleBG;

        let length = Object.keys(story).length;

        let s = ""
        for (let i = 0; i < length; i++) {
            s += constructWordString(styleFG[i], styleBG[i], story[i], storyOwner[i], storyValue[i]);
        }
        $("#inner").empty();
        $(s).appendTo("#inner");
        $(".word").each(function(i){
            $(this).css("z-index", i + 1);
        });

        anime({
            targets: ".word",
            opacity: [0, 1],
            delay: anime.stagger(150, {start: 0}),
            duration: 1000,
            complete: function(anim) {
                $(".word").css("position", "initial");
            }
        });

        anime({
            targets: ".lds-ellipsis",
            opacity : [1, 0],
            duration: 300,
            easing: "easeOutQuad"
        });

        storyInitComplete = true;
        processEditingUsers()
    }

    function processEditingUsers() {
        $(".word").each(function(i) {
            if (EditingUsers[i] !== 0) {
                this.addClass("editing");
            }
        });
    }

    function onJSONsuccess(data) {


        if(data.result) {
            switch(data.id) {
                case CALL_ID.GET_STORY_TODAY:
                    initTodayStory(data);
                    break;
                case CALL_ID.GET_STORY_IN_RANGE:
                    break;
                case CALL_ID.GET_STORY_DATE:
                    break;
                case CALL_ID.GET_DEFAULT_BG:
                    break;
                case CALL_ID.GET_DEFAULT_FG:
                    break;
                case CALL_ID.GET_MIN_AMOUNT:
                    minAmount = IconService.IconAmount.of(data.result, IconService.IconAmount.Unit.ICX);
                    break;
                case CALL_ID.REPLACE_WORD:
                    Swal.close();
                    Swal.fire({
                        text: "Pending transaction..." ,
                        footer: "txid: " + data.result,
                        allowOutsideClick: false,
                        onBeforeOpen: () => {
                            Swal.showLoading();
                        }
                    });
                    keepTrying(verifyTX, data.result, onReplaceWord);
                    break;
                case CALL_ID.ADD_NORMAL_WORD:
                    Swal.close();
                    Swal.fire({
                        text: "Pending transaction..." ,
                        footer: "txid: " + data.result,
                        allowOutsideClick: false,
                        onBeforeOpen: () => {
                            Swal.showLoading();
                        }
                    });
                    keepTrying(verifyTX, data.result, onNormalWordAdded);
                    break;
                case CALL_ID.ADD_FANCY_WORD:
                    Swal.close();
                    Swal.fire({
                        text: "Pending transaction..." ,
                        footer: "txid: " + data.result,
                        allowOutsideClick: false,
                        onBeforeOpen: () => {
                            Swal.showLoading();
                        }
                    });
                    keepTrying(verifyTX, data.result, onNormalWordAdded);
                    break;
                default:
                    if ((data.id + "").includes(CALL_ID.UPDATE_STORY)) {
                        let arr = data.id.split("_")
                        let index = parseInt(arr[1]);
                        let isInsert = parseInt(arr[2]);
                        updateStoryGraphics(data, index, isInsert);
                    }
                    break;
            }
        }
        console.log(data)
    }

    function keepTrying(f, arg, callback) {
        f(arg).then(response => {
            callback(response);
        }).catch(e => {
            console.log(e);
            if (e.includes("Pending") || e.includes("txHash")) {
                setTimeout(function () {
                    keepTrying(f, arg, callback);
                }, 1000);
            }
        });
    }

    verifyTX = async function (tx) {
        const txresult = await iconService.getTransactionResult(tx).execute();
        return txresult;
    };

    onNormalWordAdded = function(result) {
        Swal.close();
        if (result.status === 1) {
            console.log(result);
            finishWriting(recentlyEditedIndex, true);
            Swal.fire({
                type: "success",
                title: "Success!",
                text: "Your word was successfully added.",
                timer: 2000
            });
        } else {
            Swal.fire({
                type: 'error',
                title: 'Oops...',
                text: result.failure.message
            })
        }
    }

    onReplaceWord = function (result) {
        Swal.close();
        if (result.status === 1) {
            console.log("OnReplaceWord");
            console.log(result);
            finishWriting(recentlyEditedIndex, false);
            Swal.fire(
                'Success!',
                'Your word was successfully added.',
                'success'
            );
        } else {
            console.log(result);
            Swal.fire({
                type: 'error',
                title: 'Oops...',
                text: result.failure.message
            })
        }
    }

    const checkForICONEX = new CustomEvent('ICONEX_RELAY_REQUEST', {
        detail: {
            type: 'REQUEST_HAS_ACCOUNT'
        }
    });

    const askForAddress = new CustomEvent('ICONEX_RELAY_REQUEST', {
        detail: {
            type: 'REQUEST_ADDRESS'
        }
    });

    // methodType = "icx_sendTransaction" || "icx_call"
    function relayRequest(data) {
        if (!data) {
            Swal.fire({
                type: "error",
                text: 'Check the param data.'
            })
            return;
        }
        else {
            const parsed = JSON.parse(data);

            if (parsed.method === "icx_sendTransaction" && (fromAddress === "")) {
                Swal.fire({
                    type: 'error',
                    title: "ICX Address not selected",
                    text: 'Please choose your ICX Address from your ICONEX extension.'
                });
                window.dispatchEvent(askForAddress);
                return;
            }

            if (parsed.method === "icx_sendTransaction") {
                Swal.fire({
                    type: 'info',
                    title: "Sending transaction...",
                    text: 'We have requested a transaction. Please follow the instruction and sign the transaction on the ICONex popup.',
                    footer: "Our SCORE implements Fee 2.0 with 100% proportion, meaning you don't pay any transaction fee."
                });
            }

            console.log("[ICONEX] sending json call...")
            console.log(parsed);

            window.dispatchEvent(new CustomEvent('ICONEX_RELAY_REQUEST', {
                detail: {
                    type: 'REQUEST_JSON-RPC',
                    payload: parsed
                }
            }));
        }
    }

    function makeGoodCall(scoreData) {
        if (!isICONEX) {
            makePostCall(scoreData);
        } else {
            relayRequest(JSON.stringify(scoreData));
        }
    }

    getStoryToday = function () {
        const callBuilder = new IconBuilder.CallBuilder;
        const call = callBuilder
            .to(scoreAddress)
            .method('getCurrentStory')
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_call",
            "params": call,
            "id": CALL_ID.GET_STORY_TODAY
        };
        makeGoodCall(scoreData);
    };

    updateStory = function (index, isInsert) {
        isInsert = isInsert ? 1 : 0;
        const callBuilder = new IconBuilder.CallBuilder;
        const call = callBuilder
            .to(scoreAddress)
            .method('getWord')
            .params({"word_index" : IconConverter.toBigNumber(index)})
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_call",
            "params": call,
            "id": CALL_ID.UPDATE_STORY + "_" + index + "_" + isInsert
        };
        makeGoodCall(scoreData);
    };

    getStoryDate = function (date) {
        const callBuilder = new IconBuilder.CallBuilder;
        const call = callBuilder
            .to(scoreAddress)
            .method('getStoryOfDate')
            .params({"date" : IconConverter.toBigNumber(date)})
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_call",
            "params": call,
            "id": CALL_ID.GET_STORY_DATE
        };
        makeGoodCall(scoreData);
    };

    getMinAmount = function () {
        const callBuilder = new IconBuilder.CallBuilder;
        const call = callBuilder
            .to(scoreAddress)
            .method('getFancywordsAmount')
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_call",
            "params": call,
            "id": CALL_ID.GET_MIN_AMOUNT
        };
        makeGoodCall(scoreData);
    };

    function checkForICONex() {
        if (fromAddress === ""){
            if (isICONEX) {
                Swal.fire({
                    type: 'warning',
                    title: "ICX Address not selected",
                    text: 'Please choose your ICX Address from your ICONEX extension.',
                    timer: 5000
                });
                window.dispatchEvent(askForAddress);
                return false;
            }
            else {
                Swal.fire({
                    type: 'error',
                    title: 'Oops...',
                    text: 'Wallet not detected. Please download ICONex Chrome extension.',
                    footer: '<a href="https://chrome.google.com/webstore/detail/iconex/flpiciilemghbmfalicajoolhkkenfel?hl=en">Download ICONex from Chrome web store</a>'
                })
                return false;
            }
        }
        return true;
    }

    getStoryRange = function (dateFrom, dateTo) {
        const callBuilder = new IconBuilder.CallBuilder;
        const call = callBuilder
            .to(scoreAddress)
            .method('getStoryInRange')
            .params({"fromTimestamp" : IconConverter.toBigNumber(dateFrom), "toTimestamp" : IconConverter.toBigNumber(dateTo)})
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_call",
            "params": call,
            "id": CALL_ID.GET_STORY_IN_RANGE
        };
        makeGoodCall(scoreData);
    };

    addNormalWord = function (wordIndex, word, value) {
        if (!checkForICONex())
            return;

        recentlyEditedIndex = wordIndex;

        const ctBuilder = new IconBuilder.CallTransactionBuilder;
        const calltrans = ctBuilder
            .from(fromAddress)
            .to(scoreAddress)
            .value(value)
            .nid(IconConverter.toBigNumber(3))
            .timestamp((new Date()).getTime() * 1000)
            .stepLimit(IconConverter.toBigNumber(10000000))
            .version(IconConverter.toBigNumber(3))
            .method('addNormalWord')
            .params({
                "word_index" : IconConverter.toBigNumber(wordIndex),
                "word" :  word})
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_sendTransaction",
            "params": IconConverter.toRawTransaction(calltrans),
            "id": CALL_ID.ADD_NORMAL_WORD
        };
        makeGoodCall(scoreData);
    };

    replaceWord = function (wordIndex, word, value) {
        if (!checkForICONex())
            return;

        recentlyEditedIndex = wordIndex;

        const ctBuilder = new IconBuilder.CallTransactionBuilder;
        const calltrans = ctBuilder
            .from(fromAddress)
            .to(scoreAddress)
            .value(value)
            .nid(IconConverter.toBigNumber(3))
            .timestamp((new Date()).getTime() * 1000)
            .stepLimit(IconConverter.toBigNumber(10000000))
            .version(IconConverter.toBigNumber(3))
            .method('replaceWord')
            .params({
                "word_index" : IconConverter.toBigNumber(wordIndex),
                "word" :  word,
                "style_fg" : "0xffffff",
                "style_bg" : "0x000000"
            })
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_sendTransaction",
            "params": IconConverter.toRawTransaction(calltrans),
            "id": CALL_ID.REPLACE_WORD
        };

        makeGoodCall(scoreData);

    };

    addFancyWord = function (wordIndex, word, value, fg, bg) {
        if (!checkForICONex())
            return;

        recentlyEditedIndex = wordIndex;

        const ctBuilder = new IconBuilder.CallTransactionBuilder;
        const calltrans = ctBuilder
            .from(fromAddress)
            .to(scoreAddress)
            .value(value)
            .nid(IconConverter.toBigNumber(3))
            .timestamp((new Date()).getTime() * 1000)
            .stepLimit(IconConverter.toBigNumber(10000000))
            .version(IconConverter.toBigNumber(3))
            .method('addFancyWord')
            .params({
                "word_index" : IconConverter.toBigNumber(wordIndex),
                "word" :  word,
                "style_fg" : fg,
                "style_bg" : bg
            })
            .build();
        const scoreData = {
            "jsonrpc": "2.0",
            "method": "icx_sendTransaction",
            "params": IconConverter.toRawTransaction(calltrans),
            "id": CALL_ID.ADD_FANCY_WORD
        };
        makeGoodCall(scoreData);
    }


    $( window ).on("load", function() {


        anime({
            targets: '#container',
            opacity: 1,
            duration: 2000,
            delay: 100,
            easing: "linear"
        });

        anime({
            targets: '#container',
            translateX: ["-3vw", 0],
            translateY: ["-30vh", 0], // from 100 to 250
            duration: 2000,
            rotate: [anime.random(-10, -20), 0],
            delay: 100
        });

        window.dispatchEvent(checkForICONEX);
        getMinAmount();
        getStoryToday();

    });

</script>

</body>
</html>
